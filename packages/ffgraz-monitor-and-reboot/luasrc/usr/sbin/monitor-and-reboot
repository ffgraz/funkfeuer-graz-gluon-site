#!/usr/bin/lua

-- Load modules
require "ubus"
require "uloop"
local uci = require('simple-uci').cursor()

uloop.init()

-- Establish connection
local conn = ubus.connect()
if not conn then
	error("Failed to connect to ubusd")
end

local prod = os.getenv('MAR_PROD') == '1'

local dry = not prod
local debug = not prod
local rollover = 6 * 60 * 60
local rebootGrace = 60 * 60
local rebootRollover = 24 * 60 * 60
local rebootMax = 3

local triggers = {
	ddhcpd = {
		find = { 'dnsmasq', 'Address already in use' },
		count = 10,

		try_grace = 60,
		try_first = {
			-- order matters
			'service dnsmasq stop',
			'service ddhcpd stop',
			'service dnsmasq start',
			'service ddhcpd start',
		},
	},
	ddhcpd = {
		find = { 'ddhcpd', 'ERROR:' },
		count = 10,

		min_uptime = 600,

		try_grace = 60,
		try_first = {
			'service ddhcpd restart',
		},
	},
	respondd = {
		find = { 'respondd', 'in use' },
		count = 5,

		try_grace = 60,
		try_first = {
			'service gluon-respondd stop',
			'killall respondd',
			'sleep 2s',
			'service gluon-respondd start',
		},
	},
	mmfd = {
		find = { 'mmfd', 'unreachable' },
		count = 10,

		try_grace = 60,
		try_first = {
			'service mmfd stop',
			'sleep 2s',
			'service mmfd start',
		}
	}
}

local state = {}
local entries = {}

for trigger, _ in pairs(triggers) do
	state[trigger] = {
		count = 0,
		tried = 0,
	}
end

local function dlog(...)
	if debug then
		arg[1] = '[DEBUG REBOOT] ' .. arg[1]
		print(string.format(unpack(arg)))
	end
end

local function elog(...)
	arg[1] = '[m-a-r] ' .. arg[1]
	conn:call('log', 'write', { event = string.format(unpack(arg)) })

	if debug then
		dlog(unpack(arg))
	end
end

local function get_count(trigger)
	local count = 0
	local newTable = {}

	for _, e in ipairs(entries) do
		if e[2] + rollover > os.time() then
			table.insert(newTable, e)

			if e[1] == trigger then
				count = count + 1
			end
		end
	end

	entries = newTable

	return count
end

local function countReboots()
	local list = uci:get_list('ffgraz-monitor-and-reboot', 'state', 'reboots')
	local newList = {}
	local count = 0
	local needSave = false
	local last = 0

	if not list then
		return count, last
	end

	for _, ts in ipairs(list) do
		if tonumber(ts) + rebootRollover > os.time() then
			count = count + 1
			table.insert(newList, ts)
			last = tonumber(ts)
		else
			needSave = true
		end
	end

	if needSave then
		uci:set_list('ffgraz-monitor-and-reboot', 'state', 'reboots', newList)
		uci:save('ffgraz-monitor-and-reboot')
		os.execute('uci commit')
	end

	return count, last
end

local function maybeReboot(trigger, old)
	dlog('maybe reboot triggered')
	local count, last = countReboots()
	dlog('count %s, last %s', count, last)

	if count < rebootMax and last + rebootGrace < os.time() and not old then
		elog('rebooting because of %s failure!', trigger)
		elog('count %s/%s, grace left %s', count, rebootMax, (last + rebootGrace) - os.time())
		
		dlog('store...')
		local list = uci:get_list('ffgraz-monitor-and-reboot', 'state', 'reboots') or {}
		table.insert(list, tostring(os.time()))
		uci:set_list('ffgraz-monitor-and-reboot', 'state', 'reboots', list)
		uci:save('ffgraz-monitor-and-reboot')
		os.execute('sleep 2s')
		os.execute('uci commit')
		os.execute('sleep 2s')
		
		if not dry then
			os.execute('reboot')
		else
			dlog('[dry reboot]')
			os.exit(0)
		end
	else
		if old then
			dlog('[ old message ]: count %s/%s, grace left %s', count, rebootMax, (last + rebootGrace) - os.time())
		else
			elog('not rebooting %s: count %s/%s, grace left %s', trigger, count, rebootMax, (last + rebootGrace) - os.time())
		end
	end
end

local uptime_file = assert(io.open("/proc/uptime", "r"))
local uptime = math.floor(assert(uptime_file:read("*number")))
uptime_file:close()

local boottime = os.time() - uptime

local function handleLog (log, old)
	if log.msg:find('DEBUG REBOOT') then
		return
	end

	local time = math.floor(log.time / 1000)

	for trigger, t in pairs(triggers) do
		local s = state[trigger]

		local satisfied = true

		for _, cond in ipairs(t.find) do
			if not log.msg:find(cond) then
				satisfied = false
			end
		end

		if satisfied then
			dlog('%s satisfied', trigger)

			count = get_count(trigger)

			if not s.min_uptime or ((time - boottime) > t.min_uptime) then
				table.insert(entries, { trigger, time })

				dlog('count at %s from max %s', count, t.count)
				if count >= t.count then
					maybeReboot(trigger, old)
				end

				if (not t.try_count or t.try_count <= count) and not (s.tried + t.try_grace > time) and not old then
					s.tried = time
					elog('trying to fix %s', trigger)
					for _, cmd in ipairs(t.try_first) do
						dlog('try %s', cmd)
						if not dry then
							os.execute(cmd)
						else
							dlog('[dry]')
						end
					end
				end
			else
				dlog('not enough uptime - current %s req %s', os.uptime(), t.min_uptime)
			end
		end
	end
		
end

-- Say hello
elog('starting...')

-- Stream logs
local prev = conn:call("log", "read", { stream = false, oneshot = true, lines = 1024 * 1024 })
for _, log in ipairs(prev.log) do
	handleLog(log, true)
end

local ret = conn:call("log", "read", { stream = true, oneshot = false, lines = 0 }, function (event, control)
	if control then
		elog(control.type)
	else
		handleLog(event)
	end
end)

uloop.run()

